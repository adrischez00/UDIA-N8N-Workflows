{
  "active": true,
  "connections": {
    "Google Calendar": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Respond to Webhook2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Calendar1": {
      "main": [
        [
          {
            "node": "Code in JavaScript2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "normalizar": {
      "main": [
        [
          {
            "node": "Google Calendar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "Respond to Webhook3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Google Calendar1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Delete an event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond to Webhook4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Calendar2": {
      "main": [
        [
          {
            "node": "Code in JavaScript4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain1": {
      "main": [
        [
          {
            "node": "JS Normalizar cancelar_cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Webhook cancelar_cita": {
      "main": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete an event": {
      "main": [
        [
          {
            "node": "Respond to Webhook5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript4": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JS Normalizar cancelar_cita": {
      "main": [
        [
          {
            "node": "Google Calendar2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook agendar": {
      "main": [
        [
          {
            "node": "Basic LLM Chain2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook comprobar_disponibilidad": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript2": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain2": {
      "main": [
        [
          {
            "node": "normalizar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain3": {
      "main": [
        [
          {
            "node": "JS normalizar_modificar_citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook modificar_cita": {
      "main": [
        [
          {
            "node": "Basic LLM Chain3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many events": {
      "main": [
        [
          {
            "node": "JS Buscar_evento_modificar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Update an event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond to Webhook6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update an event": {
      "main": [
        [
          {
            "node": "Respond to Webhook7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JS normalizar_modificar_citas": {
      "main": [
        [
          {
            "node": "Get many events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JS Buscar_evento_modificar": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-11-24T01:36:27.807Z",
  "id": "3JFoRTuAWwR3OGO8",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Agente voz Retell AI",
  "nodes": [
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "start": "={{ $json.start_time }}",
        "end": "={{ $json.end_time }}",
        "additionalFields": {
          "color": "={{ $json.colorId }}",
          "description": "=El Telefono de  {{ $('Webhook agendar').item.json.body.args.Nombre }} es {{ $('Webhook agendar').item.json.body.args.Telefono }}",
          "showMeAs": "opaque",
          "summary": "=Cita para {{ $('Webhook agendar').item.json.body.args.Nombre }} en {{ $('Webhook agendar').item.json.body.args.Servicio }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        1824,
        256
      ],
      "id": "53331156-b482-4042-b217-aa94f9ecf2b7",
      "name": "Google Calendar",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"msg\": \"la cita se agendo con exito\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2000,
        256
      ],
      "id": "c347a713-29b4-499d-9bff-12defe90ac92",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.available }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "24da48cd-2d7c-4566-8ecd-8faa459734e6"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "si"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7186af82-750a-4a2e-86f8-95590d35cd92",
                    "leftValue": "={{ $json.available }}",
                    "rightValue": "false",
                    "operator": {
                      "type": "boolean",
                      "operation": "false",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "no"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        160,
        272
      ],
      "id": "8df7b5d1-4e6a-4659-8ded-34775febc2c0",
      "name": "Switch"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"msg\": \"no hay disponibilidad\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        592,
        592
      ],
      "id": "e44c2ad9-798f-4b56-a10e-83a73dc02237",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "returnAll": true,
        "timeMin": "={{ $json.start_time }}",
        "timeMax": "={{ $json.end_time }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -256,
        272
      ],
      "id": "cff94d79-d2de-47d9-99a2-8828da10973a",
      "name": "Google Calendar1",
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"msg\": \"si hay\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        624,
        0
      ],
      "id": "50e31d01-e219-4846-b44b-34c60469ac9f",
      "name": "Respond to Webhook2"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst items = $input.all();\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  HELPERS ZONA HORARIA MADRID       ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nfunction ahoraMadrid() {\n  return new Date(\n    new Date().toLocaleString('en-US', { timeZone: 'Europe/Madrid' })\n  );\n}\n\nfunction fechaMadridISO(diasOffset = 0) {\n  const ahora = ahoraMadrid();\n  ahora.setDate(ahora.getDate() + diasOffset);\n  return ahora.toISOString().slice(0, 10); // YYYY-MM-DD\n}\n\nfunction normalizarFecha(fechaTexto) {\n  const ahora = ahoraMadrid();\n  const hoyStr = ahora.toISOString().slice(0, 10);\n\n  if (!fechaTexto) {\n    return fechaMadridISO(1);\n  }\n\n  if (/^hoy$/i.test(fechaTexto)) {\n    return hoyStr;\n  }\n\n  if (/^ma√±ana$/i.test(fechaTexto)) {\n    return fechaMadridISO(1);\n  }\n\n  if (/^\\d{4}-\\d{2}-\\d{2}$/.test(fechaTexto)) {\n    const fecha = new Date(`${fechaTexto}T00:00:00`);\n    if (fecha < ahora) {\n      return fechaMadridISO(1);\n    }\n    return fechaTexto;\n  }\n\n  // Cualquier formato raro ‚Üí ma√±ana (fallback)\n  return fechaMadridISO(1);\n}\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  CONFIG SERVICIOS: COLOR + DURACI√ìN‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\n// Mapa servicio ‚Üí colorId (1‚Äì11 en Google Calendar)\nconst mapaServicioColor = {\n  'medicina general': '1', // azul\n  'odontologia':      '2', // verde\n  'odontolog√≠a':      '2',\n  'fisioterapia':     '3', // morado\n  'fisio':            '3',\n  'estetica':         '5', // amarillo\n  'est√©tica':         '5',\n};\n\n// Mapa servicio ‚Üí duraci√≥n en minutos\nconst mapaDuracionServicioMin = {\n  'medicina general': 30,\n  'odontologia':      45,\n  'odontolog√≠a':      45,\n  'fisioterapia':     60,\n  'fisio':            60,\n  'estetica':         45,\n  'est√©tica':         45,\n};\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  PROCESADO PRINCIPAL               ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nconst output = items.map((item) => {\n  const body = item.json.body || {};\n  const args = body.args || {};   // Datos de Retell\n\n  // ‚ñë‚ñë 1) Parsear salida del Basic LLM ‚ñë‚ñë\n  const llmRaw = item.json.text || item.json.response || '';\n  let parsed = {};\n  try {\n    parsed = JSON.parse(llmRaw);\n  } catch (e) {\n    parsed = {};\n  }\n\n  // Campos que viene del LLM (seg√∫n tu prompt)\n  const fechaLlm       = parsed.fecha || null;          // \"YYYY-MM-DD\" o null\n  const horaLlm        = parsed.hora || null;           // \"HH:MM\" o null\n  const ambiguedadLlm  = parsed.ambiguedad || 'none';\n  const fechaTextoOrig = parsed.texto_original_fecha || '';\n  const horaTextoOrig  = parsed.texto_original_hora  || '';\n\n  // ‚ñë‚ñë 2) Fecha/hora ORIGINAL para logs/descripci√≥n ‚ñë‚ñë\n  const fechaOriginal =\n    fechaTextoOrig ||\n    args.Fecha || args.fecha || body.Fecha || body.fecha || '';\n\n  let horaOriginal =\n    horaTextoOrig ||\n    args.Hora || args.hora || body.Hora || body.hora || '12:00';\n\n  // ‚ñë‚ñë 3) Servicio, nombre, tel√©fono ‚ñë‚ñë\n  const servicio =\n    args.Servicio || args.servicio || body.servicio || 'Cita';\n\n  const nombre =\n    args.Nombre || args.nombre || body.Nombre || body.nombre || 'Paciente';\n\n  const telefono =\n    args.Telefono || args.telefono || body.Telefono || body.telefono || '';\n\n  // ‚≠ê Normalizamos el servicio (para color y duraci√≥n)\n  const servicioLimpio = servicio\n    .toLowerCase()\n    .normalize('NFD')              // quita tildes\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .trim();\n\n  // ‚≠ê Color seg√∫n servicio\n  const colorId = mapaServicioColor[servicioLimpio] || '9'; // 9 = gris por defecto\n\n  // ‚≠ê Duraci√≥n seg√∫n servicio (minutos)\n  const duracionMin = mapaDuracionServicioMin[servicioLimpio] || 60; // por defecto 60'\n\n  // ‚ñë‚ñë 4) Fecha/hora NORMALIZADAS ‚ñë‚ñë\n\n  // Fecha: preferimos la del LLM; si no hay, usamos nuestro fallback\n  const fechaNormalizada =\n    (fechaLlm && fechaLlm.trim()) || normalizarFecha(fechaOriginal);\n\n  // Hora: preferimos la del LLM; si no, usamos la original\n  let horaNormalizada = (horaLlm && horaLlm.trim()) || horaOriginal;\n\n  // 5) Normalizamos hora a HH:MM\n  const partesHora = horaNormalizada.split(':');\n  let h = (partesHora[0] || '').replace(/[^\\d]/g, '');\n  if (!h) h = '12';\n  h = h.padStart(2, '0');\n  const m = (partesHora[1] || '00').padStart(2, '0');\n  const hora = `${h}:${m}`;\n\n  // 6) Construimos start\n  const start = `${fechaNormalizada}T${hora}:00`;\n\n  // 7) Calculamos end sumando la duraci√≥n en minutos\n  let hNum = parseInt(h, 10);\n  let mNum = parseInt(m, 10);\n\n  let totalMin = hNum * 60 + mNum + duracionMin;\n  let endHourNum = Math.floor(totalMin / 60);\n  let endMinNum = totalMin % 60;\n\n  if (endHourNum > 23) endHourNum = 23; // seguridad\n\n  const endHoraStr = `${String(endHourNum).padStart(2, '0')}:${String(\n    endMinNum\n  ).padStart(2, '0')}:00`;\n  const end = `${fechaNormalizada}T${endHoraStr}`;\n\n  // 8) Summary y descripci√≥n\n  const summary = `Cita para ${nombre} en ${servicio}`;\n\n  const descriptionLines = [\n    `Servicio: ${servicio}`,\n    `Nombre: ${nombre}`,\n    telefono ? `Tel√©fono: ${telefono}` : '',\n    fechaOriginal ? `Fecha original solicitada: ${fechaOriginal}` : '',\n    `Duraci√≥n prevista: ${duracionMin} minutos`,\n    ambiguedadLlm && ambiguedadLlm !== 'none'\n      ? `Ambig√ºedad detectada por IA: ${ambiguedadLlm}`\n      : '',\n  ].filter(Boolean);\n\n  const description = descriptionLines.join('\\n');\n\n  // 9) Devolvemos payload para el nodo de Google Calendar\n  return {\n    json: {\n      ...item.json,\n      fecha_original: fechaOriginal,\n      fecha_normalizada: fechaNormalizada,\n      hora_original: horaOriginal,\n      hora_normalizada: hora,\n      duracion_min: duracionMin,\n      start_time: start,\n      end_time: end,\n      summary,\n      description,\n      colorId,\n      ambiguedad_llm: ambiguedadLlm,\n    },\n  };\n});\n\nreturn output;\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1648,
        256
      ],
      "id": "c20f6356-1d39-4503-9d65-025c095f7b8f",
      "name": "normalizar"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Hoy es {{ $now.toISODate() }}.\n\nTexto de fecha del usuario: \"{{ $json.body.fecha || '' }}\".\nTexto de hora del usuario: \"{{ $json.body.hora || '' }}\".\n\nDevu√©lveme SOLO un JSON en este formato EXACTO:\n\n{\n  \"fecha\": \"YYYY-MM-DD o null\",\n  \"hora\": \"HH:MM o null\",\n  \"ambiguedad\": \"none\" | \"low\" | \"high\",\n  \"texto_original_fecha\": \"...\",\n  \"texto_original_hora\": \"...\"\n}\n",
        "messages": {
          "messageValues": [
            {
              "message": "Eres un parser de fecha y hora para una cl√≠nica en Espa√±a.  Trabajas siempre en zona horaria Europe/Madrid.  Debes recibir un texto de fecha, un texto de hora y la fecha de hoy. Tu misi√≥n es interpretar expresiones naturales como: - \"ma√±ana\", \"pasado ma√±ana\" - \"el viernes\", \"este jueves\", \"el viernes que viene\", \"el pr√≥ximo martes\" - \"por la ma√±ana\", \"mediod√≠a\", \"por la tarde\", \"por la noche\"  Reglas: - \"ma√±ana\" = hoy + 1 d√≠a. - \"pasado ma√±ana\" = hoy + 2 d√≠as. - \"el viernes\" o \"este viernes\" = pr√≥ximo viernes respecto a hoy (si hoy es viernes, el siguiente). - \"el viernes que viene\" y \"el pr√≥ximo viernes\" = tambi√©n el pr√≥ximo viernes. - \"por la ma√±ana\" = 10:00, \"mediod√≠a\" = 12:00, \"por la tarde\" = 16:00, \"por la noche\" = 20:00 si no hay hora m√°s precisa. - Si la fecha queda muy ambigua (\"cuando puedas\", \"un d√≠a de estos\"), deja fecha y hora a null y pon \"ambiguedad\": \"high\".  Nunca escribas nada fuera del JSON. NO pongas explicaciones, s√≥lo el JSON."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -1152,
        304
      ],
      "id": "14b2ad6b-857e-43f0-b0c7-bb1223e7a110",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1152,
        480
      ],
      "id": "05913cf4-f4ea-4bd2-b681-8394657ae757",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "UUb7LT0t44WTS54p",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst items = $input.all();\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  HELPERS HORARIO CL√çNICA           ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\n// Devuelve la configuraci√≥n de horario para ese d√≠a\nfunction obtenerHorarioClinica(fechaISO) {\n  // fechaISO: \"YYYY-MM-DD\"\n  const fecha = new Date(`${fechaISO}T00:00:00`);\n  const diaSemana = fecha.getDay(); // 0 = domingo ... 6 = s√°bado\n\n  // Domingos cerrados\n  if (diaSemana === 0) {\n    return {\n      abierto: false,\n      abreMin: null,\n      cierraMin: null,\n      texto: 'Domingos la cl√≠nica est√° cerrada.',\n    };\n  }\n\n  // S√°bado: 9:00 ‚Äì 14:00\n  if (diaSemana === 6) {\n    return {\n      abierto: true,\n      abreMin: 9 * 60,\n      cierraMin: 14 * 60,\n      texto: 'S√°bados: 9:00 a 14:00.',\n    };\n  }\n\n  // Lunes‚ÄìViernes: 9:00 ‚Äì 19:00\n  return {\n    abierto: true,\n    abreMin: 9 * 60,\n    cierraMin: 19 * 60,\n    texto: 'De lunes a viernes: 9:00 a 19:00.',\n  };\n}\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  PROCESADO PRINCIPAL               ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nconst output = items.map(item => {\n  const body = item.json.body || {};\n\n  // 1) Leer respuesta cruda del LLM\n  // Cambia 'response' por el nombre real de la propiedad (ej: 'text')\n  const llmRaw = item.json.response || item.json.text || '';\n\n  let parsed;\n  try {\n    parsed = JSON.parse(llmRaw);\n  } catch (e) {\n    // Fallback si viene roto\n    parsed = {\n      fecha: null,\n      hora: null,\n      ambiguedad: 'high',\n      texto_original_fecha: body.args?.Fecha || body.Fecha || '',\n      texto_original_hora: body.args?.Hora || body.Hora || '',\n    };\n  }\n\n  const fechaNormalizada = parsed.fecha;      // \"YYYY-MM-DD\" o null\n  let   horaNormalizada  = parsed.hora;       // \"HH:MM\" o null\n  const ambiguedad       = parsed.ambiguedad; // \"none\"/\"low\"/\"high\"\n\n  // 2) Si falta fecha o es muy ambiguo ‚Üí marcar para que el bot pida aclaraci√≥n\n  if (!fechaNormalizada || ambiguedad === 'high') {\n    return {\n      json: {\n        ...item.json,\n        necesita_aclaracion: true,\n        motivo: 'fecha_hora_ambigua',\n        llm_response: parsed,\n      },\n    };\n  }\n\n  // 3) Hora por defecto si viene null (puedes cambiar a lo que quieras)\n  if (!horaNormalizada) {\n    horaNormalizada = '10:00';\n  }\n\n  // Normalizar HH:MM\n  const partes = horaNormalizada.split(':');\n  let h = (partes[0] || '10').replace(/[^\\d]/g, '');\n  let m = (partes[1] || '00').replace(/[^\\d]/g, '');\n  h = h.padStart(2, '0');\n  m = m.padStart(2, '0');\n  const hora = `${h}:${m}`;\n\n  // 4) Comprobar si est√° dentro del horario de la cl√≠nica\n  const horario = obtenerHorarioClinica(fechaNormalizada);\n  const hNum = parseInt(h, 10);\n  const mNum = parseInt(m, 10);\n  const minutosInicio = hNum * 60 + mNum;\n\n  let dentroHorario = true;\n  let motivoFuera = '';\n\n  if (!horario.abierto) {\n    dentroHorario = false;\n    motivoFuera = 'dia_cerrado';\n  } else if (minutosInicio < horario.abreMin || minutosInicio >= horario.cierraMin) {\n    dentroHorario = false;\n    motivoFuera = 'fuera_rango_horario';\n  }\n\n  // 5) Construimos start / end (aqu√≠ seguimos usando +1h para comprobar solapes)\n  const start = `${fechaNormalizada}T${hora}:00`;\n\n  let endHour = parseInt(h, 10) + 1;\n  if (endHour >= 24) endHour = 23;\n  const endHoraStr = `${String(endHour).padStart(2, '0')}:${m}:00`;\n  const end = `${fechaNormalizada}T${endHoraStr}`;\n\n  return {\n    json: {\n      ...item.json,\n      fecha_normalizada: fechaNormalizada,\n      hora_normalizada: hora,\n      start_time: start,\n      end_time: end,\n      necesita_aclaracion: false,\n      ambiguedad,\n      dentro_horario: dentroHorario,\n      fuera_horario: !dentroHorario,\n      motivo_fuera_horario: motivoFuera,   // 'dia_cerrado' | 'fuera_rango_horario' | ''\n      texto_horario: horario.texto,        // texto humano con el horario\n    },\n  };\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        304
      ],
      "id": "42f00cd2-2e6c-441d-83d3-438ff4eb82ed",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fuera_horario || $json.necesita_aclaracion }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "1a63fbdf-4ecb-4ed2-9471-2a9e2b773f2c"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "no_ok"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b352c954-58b1-47e7-aa64-4a72465c17a1",
                    "leftValue": "={{ $json.fuera_horario || $json.necesita_aclaracion }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "false",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ok"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -592,
        208
      ],
      "id": "8e4029e2-0db7-46ba-8f4c-c9e985f230c1",
      "name": "Switch1"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -384,
        64
      ],
      "id": "33cece42-ae1f-47cc-b39a-796966221eea",
      "name": "Respond to Webhook3"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.found }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "24da48cd-2d7c-4566-8ecd-8faa459734e6"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "si"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7186af82-750a-4a2e-86f8-95590d35cd92",
                    "leftValue": "={{ $json.found }}",
                    "rightValue": "false",
                    "operator": {
                      "type": "boolean",
                      "operation": "false",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "no"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -576,
        1136
      ],
      "id": "dfea3341-5aed-4b31-8d7c-05dc1d098bc4",
      "name": "Switch2"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"status\": \"error\",\n  \"reason\": \"no_event_found\",\n  \"mensaje\": \"No he encontrado ninguna cita con esos datos.\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -336,
        1280
      ],
      "id": "88779fac-5cf6-4cdb-a092-821e97575f8d",
      "name": "Respond to Webhook4"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "returnAll": true,
        "timeMin": "={{ $json.start_time }}",
        "timeMax": "=",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -944,
        1136
      ],
      "id": "851b3ffe-b017-436d-bc05-7d5b122a4df5",
      "name": "Google Calendar2",
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Hoy es {{ $now.toISODate() }}.\n\nA continuaci√≥n tienes la informaci√≥n que recibo del webhook:\n\n- Texto de fecha del usuario: \"{{ $json.body.fecha || '' }}\".\n- Texto de hora del usuario: \"{{ $json.body.hora || '' }}\".\n- Nombre de la persona de la cita: \"{{ $json.body.nombre || '' }}\".\n- Tipo de servicio / especialidad de la cita: \"{{ $json.body.servicio || '' }}\".\n\nTu tarea es interpretar la fecha y la hora (zona horaria Europe/Madrid)\ny devolver SOLO un JSON en este formato EXACTO, sin texto adicional,\nsin explicaciones y sin markdown:\n\n{\n  \"fecha\": \"YYYY-MM-DD o null\",\n  \"hora\": \"HH:MM o null\",\n  \"ambiguedad\": \"none\" | \"low\" | \"high\",\n  \"texto_original_fecha\": \"...\",\n  \"texto_original_hora\": \"...\",\n  \"nombre\": \"...\",\n  \"servicio\": \"...\"\n}\n\nReglas:\n\n- \"nombre\" debe ser exactamente el texto recibido en el campo de nombre,\n  quitando espacios al principio y al final. Si no hay nombre, pon \"\" (cadena vac√≠a).\n- \"servicio\" debe ser exactamente el texto recibido en el campo de servicio,\n  quitando espacios al principio y al final. Si no hay servicio, pon \"\".\n- Si la fecha NO se entiende, pon \"fecha\": null.\n- Si la hora NO se entiende, pon \"hora\": null.\n- Usa \"ambiguedad\": \"none\" cuando fecha y hora est√©n claras.\n- Usa \"ambiguedad\": \"low\" cuando se puedan interpretar pero haya algo de duda.\n- Usa \"ambiguedad\": \"high\" cuando no se puedan interpretar bien (por ejemplo:\n  \"por la tarde\", \"sobre las diez\", \"el s√°bado que viene\" sin m√°s contexto).\n- No a√±adas ning√∫n comentario ni texto fuera del JSON.\n",
        "messages": {
          "messageValues": [
            {
              "message": "Eres un parser de fecha y hora para una cl√≠nica en Espa√±a.  Trabajas siempre en zona horaria Europe/Madrid.  Debes recibir un texto de fecha, un texto de hora y la fecha de hoy. Tu misi√≥n es interpretar expresiones naturales como: - \"ma√±ana\", \"pasado ma√±ana\" - \"el viernes\", \"este jueves\", \"el viernes que viene\", \"el pr√≥ximo martes\" - \"por la ma√±ana\", \"mediod√≠a\", \"por la tarde\", \"por la noche\"  Reglas: - \"ma√±ana\" = hoy + 1 d√≠a. - \"pasado ma√±ana\" = hoy + 2 d√≠as. - \"el viernes\" o \"este viernes\" = pr√≥ximo viernes respecto a hoy (si hoy es viernes, el siguiente). - \"el viernes que viene\" y \"el pr√≥ximo viernes\" = tambi√©n el pr√≥ximo viernes. - \"por la ma√±ana\" = 10:00, \"mediod√≠a\" = 12:00, \"por la tarde\" = 16:00, \"por la noche\" = 20:00 si no hay hora m√°s precisa. - Si la fecha queda muy ambigua (\"cuando puedas\", \"un d√≠a de estos\"), deja fecha y hora a null y pon \"ambiguedad\": \"high\".  Nunca escribas nada fuera del JSON. NO pongas explicaciones, s√≥lo el JSON."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -1440,
        1136
      ],
      "id": "54910d56-1445-4e25-a9ad-a822c8d68a16",
      "name": "Basic LLM Chain1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1440,
        1328
      ],
      "id": "8a1a7993-39fb-46aa-8adb-7958c0c187ba",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "UUb7LT0t44WTS54p",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "045fe328-6c09-476f-9b14-c918a891a0ca",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1632,
        1136
      ],
      "id": "3de69ed2-053b-481d-b6e9-e7e49a0a2c59",
      "name": "Webhook cancelar_cita",
      "webhookId": "045fe328-6c09-476f-9b14-c918a891a0ca"
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "eventId": "={{ $json.eventId }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        -368,
        1040
      ],
      "id": "08c9f2a7-daf1-4be2-a4d9-f4db7db3579e",
      "name": "Delete an event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"status\": \"ok\",\n  \"accion\": \"cancelar\",\n  \"nombre\": \"{{$json.nombre}}\",\n  \"servicio\": \"{{$json.servicio}}\",\n  \"fecha\": \"{{$json.fecha_normalizada}}\",\n  \"hora\": \"{{$json.hora_normalizada}}\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -160,
        1040
      ],
      "id": "592bfefa-51e8-4ee7-8f6f-e8cd87dfc570",
      "name": "Respond to Webhook5"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst eventos = $input.all();\n\n// üìå Datos normalizados de la cita que quieres cancelar\nconst baseNorm = ($node[\"JS Normalizar cancelar_cita\"]?.json) || {};\n\n// Campos originales\nconst nombreOriginal = baseNorm.nombre || \"\";\nconst servicioOriginal =\n  baseNorm.servicio || baseNorm.servicio_limpio || \"\";\n\n// Normalizar nombre y servicio (min√∫sculas + sin tildes)\nconst nombre = nombreOriginal.toString().toLowerCase().trim();\nconst servicio = servicioOriginal\n  .toString()\n  .toLowerCase()\n  .normalize(\"NFD\")\n  .replace(/[\\u0300-\\u036f]/g, \"\")\n  .trim();\n\n// üõë Si falta nombre o servicio, no tocamos nada\nif (!nombre || !servicio) {\n  return [\n    {\n      json: {\n        ...baseNorm,\n        found: false,\n        necesita_aclaracion: true,\n        motivo:\n          \"Faltan nombre y servicio para identificar la cita con seguridad\",\n        debug_nombre: nombreOriginal,\n        debug_servicio: servicioOriginal,\n      },\n    },\n  ];\n}\n\nlet coincidencias = [];\n\n// üîé Buscar SOLO por nombre + servicio dentro de los eventos devueltos\nfor (const item of eventos) {\n  const ev = item.json || {};\n\n  const texto = (\n    (ev.summary || \"\") +\n    \" \" +\n    (ev.description || \"\")\n  )\n    .toLowerCase()\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\");\n\n  const nombreSinTildes = nombre\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\");\n\n  const matchNombre = texto.includes(nombreSinTildes);\n  const matchServicio = texto.includes(servicio);\n\n  if (matchNombre && matchServicio) {\n    coincidencias.push(ev);\n  }\n}\n\nif (coincidencias.length === 0) {\n  return [\n    {\n      json: {\n        ...baseNorm,\n        found: false,\n        necesita_aclaracion: true,\n        motivo:\n          \"No se ha encontrado ninguna cita con ese nombre y servicio en ese horario\",\n        debug_nombre: nombreOriginal,\n        debug_servicio: servicioOriginal,\n      },\n    },\n  ];\n}\n\nif (coincidencias.length > 1) {\n  return [\n    {\n      json: {\n        ...baseNorm,\n        found: false,\n        necesita_aclaracion: true,\n        motivo:\n          \"Hay varias citas con ese nombre y servicio en ese horario. No se puede cancelar de forma segura.\",\n        debug_nombre: nombreOriginal,\n        debug_servicio: servicioOriginal,\n      },\n    },\n  ];\n}\n\n// ‚úÖ Una √∫nica coincidencia\nconst eventoEncontrado = coincidencias[0];\n\nconst start =\n  eventoEncontrado.start?.dateTime || eventoEncontrado.start?.date;\nconst hora =\n  (start && start.substring(11, 16)) ||\n  baseNorm.hora_normalizada ||\n  \"\";\n\nreturn [\n  {\n    json: {\n      ...baseNorm,\n      found: true,\n      necesita_aclaracion: false,\n      eventId: eventoEncontrado.id,\n      resumen: eventoEncontrado.summary,\n      fecha_evento: start,\n      hora_evento: hora,\n      nombre: nombreOriginal,\n      servicio_original: servicioOriginal,\n      debug_nombre: nombreOriginal,\n      debug_servicio: servicioOriginal,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        1136
      ],
      "id": "30f85f6f-7023-47b3-b86b-1dc2580602cd",
      "name": "Code in JavaScript4"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst items = $input.all();\n\n/* HELPERS HORARIO MADRID (mismos que ya usas si quieres) */\nfunction ahoraMadrid() {\n  return new Date(\n    new Date().toLocaleString('en-US', { timeZone: 'Europe/Madrid' })\n  );\n}\n\n/* Mapa de duraci√≥n por servicio (igual que en agendar) */\nconst mapaDuracionServicioMin = {\n  'medicina general': 30,\n  'odontologia': 45,\n  'odontolog√≠a': 45,\n  'fisioterapia': 60,\n  'fisio': 60,\n  'estetica': 45,\n  'est√©tica': 45,\n};\n\nconst output = items.map(item => {\n  const body = item.json.body || {};\n  const args = body.args || {};\n\n  const llmRaw = item.json.text || item.json.response || '';\n  let parsed;\n  try {\n    parsed = JSON.parse(llmRaw);\n  } catch (e) {\n    parsed = {\n      fecha: null,\n      hora: null,\n      ambiguedad: 'high',\n      texto_original_fecha: body.fecha || args.Fecha || '',\n      texto_original_hora: body.hora || args.Hora || '',\n    };\n  }\n\n  const fechaNormalizada = parsed.fecha;      // \"YYYY-MM-DD\"\n  let   horaNormalizada  = parsed.hora;       // \"HH:MM\"\n  const ambiguedad       = parsed.ambiguedad; // \"none\"/\"low\"/\"high\"\n\n  // üëá AHORA SE PRIORIZA LO QUE VIENE DEL LLM (parsed.servicio / parsed.nombre)\n  const servicio =\n    parsed.servicio ||\n    args.Servicio || args.servicio || body.servicio || 'Cita';\n\n  const nombre =\n    parsed.nombre ||\n    args.Nombre || args.nombre || body.nombre || body.Nombre || '';\n\n  // Normalizar servicio para el mapa\n  const servicioLimpio = servicio\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .trim();\n\n  const duracionMin = mapaDuracionServicioMin[servicioLimpio] || 60;\n\n  if (!fechaNormalizada || !horaNormalizada || ambiguedad === 'high') {\n    return {\n      json: {\n        ...item.json,\n        necesita_aclaracion: true,\n        motivo: 'fecha_hora_ambigua',\n        fecha_normalizada: fechaNormalizada,\n        hora_normalizada: horaNormalizada,\n        servicio,\n        nombre,\n        duracion_min: duracionMin,\n      },\n    };\n  }\n\n  // Normalizar HH:MM\n  const partes = horaNormalizada.split(':');\n  let h = (partes[0] || '10').replace(/[^\\d]/g, '');\n  let m = (partes[1] || '00').replace(/[^\\d]/g, '');\n  h = h.padStart(2, '0');\n  m = m.padStart(2, '0');\n  const hora = `${h}:${m}`;\n\n  // Construir ventana de b√∫squeda [start, end] seg√∫n duraci√≥n\n  const start = `${fechaNormalizada}T${hora}:00`;\n\n  let hNum = parseInt(h, 10);\n  let mNum = parseInt(m, 10);\n  let totalMin = hNum * 60 + mNum + duracionMin;\n  let endHourNum = Math.floor(totalMin / 60);\n  let endMinNum = totalMin % 60;\n  if (endHourNum > 23) endHourNum = 23;\n\n  const endHoraStr = `${String(endHourNum).padStart(2, '0')}:${String(endMinNum).padStart(2, '0')}:00`;\n  const end = `${fechaNormalizada}T${endHoraStr}`;\n\n  return {\n    json: {\n      ...item.json,\n      fecha_normalizada: fechaNormalizada,\n      hora_normalizada: hora,\n      start_time: start,\n      end_time: end,\n      servicio,\n      servicio_limpio: servicioLimpio,\n      nombre,\n      duracion_min: duracionMin,\n      necesita_aclaracion: false,\n      ambiguedad,\n    },\n  };\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        1136
      ],
      "id": "1d8c4123-b05e-483d-b5fe-7a908e8bc03e",
      "name": "JS Normalizar cancelar_cita"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "43e2c303-1309-46f4-af19-14b66c5a79e8",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        1200,
        256
      ],
      "id": "a4ee7935-bbde-4395-ac92-4e92ff5eb089",
      "name": "Webhook agendar",
      "webhookId": "43e2c303-1309-46f4-af19-14b66c5a79e8"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "0accefb1-8eb6-48ee-8f84-f0814f4df3e0",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1328,
        304
      ],
      "id": "9d81d259-1fc0-4511-9cba-823ad49935a7",
      "name": "Webhook comprobar_disponibilidad",
      "webhookId": "0accefb1-8eb6-48ee-8f84-f0814f4df3e0"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst eventos = $input.all();\n\n// 1) ¬øHay alg√∫n evento en ese hueco?\nconst firstJson = eventos[0]?.json || {};\nconst tieneEventos = Object.keys(firstJson).length > 0;\n\n// 2) Recuperar la info b√°sica del nodo anterior (Code in JavaScript1)\nconst base = $items('Code in JavaScript1', 0, 0).json || {};\n\n// 3) Slot disponible = NO hay eventos\nconst available = !tieneEventos;\n\n// 4) Devolvemos un √∫nico item con lo que realmente necesitamos\nreturn [\n  {\n    json: {\n      ...base,                              // fecha_normalizada, hora_normalizada, etc.\n      available,\n      eventos_en_slot: tieneEventos ? eventos.length : 0,\n    },\n  },\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        272
      ],
      "id": "c95ef3e0-b312-40a6-a2d0-0274afb7dd8a",
      "name": "Code in JavaScript2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Hoy es {{ $now.toISODate() }}.\n\nTexto de fecha del usuario: \"{{ $json.body.args.Fecha || '' }}\".\nTexto de hora del usuario: \"{{ $json.body.args.Hora || '' }}\".\n\nDevu√©lveme SOLO un JSON en este formato EXACTO:\n\n{\n  \"fecha\": \"YYYY-MM-DD o null\",\n  \"hora\": \"HH:MM o null\",\n  \"ambiguedad\": \"none\" | \"low\" | \"high\",\n  \"texto_original_fecha\": \"...\",\n  \"texto_original_hora\": \"...\"\n}\n",
        "messages": {
          "messageValues": [
            {
              "message": "=Hoy es {{ $now.toISODate() }}.\n\nTexto de fecha del usuario: \"{{ $json.body.args.Fecha || '' }}\".\nTexto de hora del usuario: \"{{ $json.body.args.Hora || '' }}\".\n\nDevu√©lveme SOLO un JSON en este formato EXACTO:\n\n{\n  \"fecha\": \"YYYY-MM-DD o null\",\n  \"hora\": \"HH:MM o null\",\n  \"ambiguedad\": \"none\" | \"low\" | \"high\",\n  \"texto_original_fecha\": \"...\",\n  \"texto_original_hora\": \"...\"\n}\n\nEres un parser de fecha y hora para una cl√≠nica en Espa√±a.\nTrabajas siempre en zona horaria Europe/Madrid.\n\nDebes interpretar expresiones naturales como:\n- \"ma√±ana\", \"pasado ma√±ana\"\n- \"el viernes\", \"este jueves\", \"el viernes que viene\", \"el pr√≥ximo martes\"\n- \"por la ma√±ana\", \"mediod√≠a\", \"por la tarde\", \"por la noche\"\n\nReglas:\n- \"ma√±ana\" = hoy + 1 d√≠a.\n- \"pasado ma√±ana\" = hoy + 2 d√≠as.\n- Para expresiones como \"el jueves\", \"este jueves\", \"el jueves que viene\", \"el pr√≥ximo jueves\":\n  SIEMPRE debes devolver el **pr√≥ximo jueves estrictamente posterior a hoy**\n  (si hoy es jueves, usa el jueves de la semana siguiente).\n- Esta misma regla se aplica a cualquier d√≠a de la semana: \"el lunes que viene\",\n  \"el pr√≥ximo martes\", etc. Siempre el siguiente d√≠a de ese tipo, nunca cambies\n  el d√≠a (no conviertas \"jueves\" en \"viernes\" ni nada similar).\n- \"por la ma√±ana\" = 10:00, \"mediod√≠a\" = 12:00, \"por la tarde\" = 16:00,\n  \"por la noche\" = 20:00 si no hay hora m√°s precisa.\n- Si la fecha queda muy ambigua (\"cuando puedas\", \"un d√≠a de estos\"),\n  deja fecha y hora a null y pon \"ambiguedad\": \"high\".\n\nNunca escribas nada fuera del JSON.\nNO pongas explicaciones, s√≥lo el JSON.\n"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1360,
        256
      ],
      "id": "9b52be91-676f-4ae7-91f8-eee564f69f58",
      "name": "Basic LLM Chain2"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1360,
        432
      ],
      "id": "f1f531f3-f77c-446b-b905-6ea3836f3024",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "UUb7LT0t44WTS54p",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Eres un parser de MODIFICAR CITAS para una cl√≠nica en Espa√±a.\nTrabajas siempre en zona horaria Europe/Madrid.\n\nTu misi√≥n es leer la frase del paciente y extraer:\n\n- nombre del paciente\n- servicio (especialidad)\n- fecha y hora ORIGINAL de la cita que quiere cambiar\n- fecha y hora NUEVA a la que quiere mover la cita\n\nNo conviertas nada a formatos t√©cnicos (ni YYYY-MM-DD ni HH:MM).\nSolo entiendes el lenguaje natural y devuelves los textos tal cual.\n\nLa fecha de hoy es: {{ $now.toISODate() }}.\n\nDatos que recibo del webhook:\n\n- Frase completa del usuario: \"{{ $json.body.texto || $json.body.text || '' }}\".\n- Nombre conocido (si viene separado): \"{{ $json.body.args?.Nombre || $json.body.nombre || '' }}\".\n- Servicio conocido (si viene separado): \"{{ $json.body.args?.Servicio || $json.body.servicio || '' }}\".\n\nDebes devolver SOLO un JSON en este formato EXACTO, sin texto adicional,\nsin explicaciones y sin markdown:\n\n{\n  \"tipo\": \"modificar\",\n  \"nombre\": \"...\",\n  \"servicio\": \"...\",\n  \"fecha_original\": \"...\",\n  \"hora_original\": \"...\",\n  \"fecha_nueva\": \"...\",\n  \"hora_nueva\": \"...\"\n}\n\nReglas:\n\n- \"nombre\":\n  - Si en la frase se menciona un nombre, √∫salo.\n  - Si no se menciona pero viene en los datos del webhook, √∫salo.\n  - Si no tienes ninguno, pon \"\" (cadena vac√≠a).\n\n- \"servicio\":\n  - Si en la frase se menciona la especialidad (por ejemplo \"medicina general\", \"fisioterapia\"),\n    √∫sala.\n  - Si no se menciona pero viene en los datos del webhook, √∫sala.\n  - Si no tienes ninguno, pon \"\".\n\n- \"fecha_original\" y \"hora_original\":\n  - Deben describir la CITA QUE YA EXISTE.\n  - Ejemplos:\n    - \"el jueves que viene\"\n    - \"ma√±ana\"\n    - \"el 4 de diciembre\"\n    - \"a las 11\"\n    - \"a las 11 y media\"\n  - Si el usuario solo dice \"mi cita de ma√±ana a las 11\", esa es la fecha/hora ORIGINAL.\n  - Si no se puede deducir una parte, pon null para ese campo.\n\n- \"fecha_nueva\" y \"hora_nueva\":\n  - Deben describir la NUEVA FECHA y HORA a la que quiere mover la cita.\n  - Ejemplos:\n    - \"el lunes\", \"para el lunes a las 5\", \"el d√≠a 5 por la tarde\".\n  - Si el usuario dice \"c√°mbiame la del jueves a las 11 al lunes a las 5\":\n    - fecha_original = \"el jueves\"\n    - hora_original = \"11\"\n    - fecha_nueva = \"el lunes\"\n    - hora_nueva = \"5\"\n  - Si s√≥lo cambia el d√≠a pero mantiene hora (\"p√°sala al mi√©rcoles\"):\n    - fecha_nueva = \"el mi√©rcoles\"\n    - hora_nueva = null (porque no se ha dicho una nueva hora).\n  - Si s√≥lo cambia la hora (\"p√°sala una hora m√°s tarde\"):\n    - fecha_nueva = null (se mantiene la misma fecha que la original).\n    - hora_nueva = \"una hora m√°s tarde\".\n      (ya se interpretar√° despu√©s con m√°s contexto).\n\n- Si la frase NO es realmente una modificaci√≥n de cita (por ejemplo, es una petici√≥n de nueva cita\n  o de cancelaci√≥n), devuelve igualmente el JSON pero con los campos que puedas y\n  deja el resto a null.\n\nNO a√±adas ning√∫n comentario ni texto fuera del JSON.\nNO escribas nada m√°s que ese JSON.\n",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1520,
        1360
      ],
      "id": "85cd1d7c-a2f9-4aa0-8fb5-6ee6db346b0b",
      "name": "Basic LLM Chain3"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1520,
        1552
      ],
      "id": "a7ab5f65-4b46-4100-83cf-40e8404e6936",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "UUb7LT0t44WTS54p",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "eventId": "={{ $json[\"eventId\"] }}",
        "updateFields": {
          "color": "={{$json[\"colorId\"]}}",
          "description": "={{$json[\"description_nuevo\"]}}",
          "end": "={{$json[\"end_nuevo\"]}}",
          "start": "={{$json[\"start_nuevo\"]}}",
          "summary": "={{$json[\"summary_nuevo\"]}}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        2656,
        1280
      ],
      "id": "f83d22f3-0d87-4234-a22a-91236dd130f1",
      "name": "Update an event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "689915ec-f9e7-45ef-8584-351c53956eb6",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        1328,
        1360
      ],
      "id": "5444a381-1044-41cb-a5aa-ecbb01c6a7d0",
      "name": "Webhook modificar_cita",
      "webhookId": "689915ec-f9e7-45ef-8584-351c53956eb6"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "286d8bc8b809b74b1e4185903f9ad6da019dd7a4d4a9f6b7690aa6914724be46@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Citas"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        2032,
        1360
      ],
      "id": "e3c41728-1a04-4662-b98a-9b01605923f5",
      "name": "Get many events",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "WDsi0a8ylFtgUPxa",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f720ff41-619c-4359-b8a9-1cad19538cef",
              "leftValue": "={{$json[\"found\"]}}",
              "rightValue": "=true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2416,
        1360
      ],
      "id": "03863dc6-a4e1-419c-a03d-635f2d379d34",
      "name": "If"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"status\": \"error\",\n  \"reason\": \"no_event_found_or_ambiguous\",\n  \"mensaje\": \"No he podido identificar con seguridad qu√© cita quieres modificar. ¬øMe confirmas el d√≠a y la hora exacta de la cita que quieres cambiar?\",\n  \"detalle\": \"{{$json.motivo || ''}}\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        2624,
        1520
      ],
      "id": "33d377de-0832-497c-8adc-135d05eda226",
      "name": "Respond to Webhook6"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"status\": \"ok\",\n  \"reason\": null,\n  \"mensaje\": \"He modificado tu cita correctamente.\",\n  \"nombre\": \"{{$json.nombre}}\",\n  \"servicio\": \"{{$json.servicio}}\",\n  \"fecha_nueva\": \"{{$json.fecha_nueva_normalizada}}\",\n  \"hora_nueva\": \"{{$json.hora_nueva_normalizada}}\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        2864,
        1280
      ],
      "id": "c16e51ee-7374-4c1c-a648-fe9c5367a826",
      "name": "Respond to Webhook7"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst items = $input.all();\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  HELPERS ZONA HORARIA MADRID       ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nfunction ahoraMadrid() {\n  return new Date(\n    new Date().toLocaleString('en-US', { timeZone: 'Europe/Madrid' })\n  );\n}\n\nfunction fechaMadridISO(diasOffset = 0) {\n  const ahora = ahoraMadrid();\n  ahora.setDate(ahora.getDate() + diasOffset);\n  return ahora.toISOString().slice(0, 10); // YYYY-MM-DD\n}\n\n/**\n * Fallback MUY sencillo para fechas por si el LLM no normaliza:\n * - \"hoy\", \"ma√±ana\"\n * - \"YYYY-MM-DD\"\n * - resto ‚Üí ma√±ana\n */\nfunction normalizarFechaFallback(fechaTexto) {\n  const ahora = ahoraMadrid();\n  const hoyStr = ahora.toISOString().slice(0, 10);\n\n  if (!fechaTexto) {\n    return fechaMadridISO(1);\n  }\n\n  const txt = String(fechaTexto).trim().toLowerCase();\n\n  if (txt === 'hoy') {\n    return hoyStr;\n  }\n\n  if (txt === 'ma√±ana' || txt === 'manana') {\n    return fechaMadridISO(1);\n  }\n\n  if (/^\\d{4}-\\d{2}-\\d{2}$/.test(txt)) {\n    const fecha = new Date(`${txt}T00:00:00`);\n    if (fecha < ahora) {\n      return fechaMadridISO(1);\n    }\n    return txt;\n  }\n\n  // Cualquier formato raro ‚Üí ma√±ana\n  return fechaMadridISO(1);\n}\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  CONFIG SERVICIOS: COLOR + DURACI√ìN‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nconst mapaServicioColor = {\n  'medicina general': '1', // azul\n  'odontologia':      '2',\n  'odontolog√≠a':      '2',\n  'fisioterapia':     '3',\n  'fisio':            '3',\n  'estetica':         '5',\n  'est√©tica':         '5',\n};\n\nconst mapaDuracionServicioMin = {\n  'medicina general': 30,\n  'odontologia':      45,\n  'odontolog√≠a':      45,\n  'fisioterapia':     60,\n  'fisio':            60,\n  'estetica':         45,\n  'est√©tica':         45,\n};\n\n/* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n   ‚ïë  PROCESADO PRINCIPAL (MODIFICAR)   ‚ïë\n   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */\n\nconst output = items.map((item) => {\n  const body = item.json.body || {};\n\n  // 1) Parsear salida del LLM de \"modificar cita\"\n  const llmRaw = item.json.text || item.json.response || '';\n  let parsed = {};\n  try {\n    parsed = JSON.parse(llmRaw);\n  } catch (e) {\n    parsed = {};\n  }\n\n  const tipo = parsed.tipo || 'modificar';\n\n  // Datos b√°sicos\n  const nombre =\n    (parsed.nombre || '').trim() ||\n    body.nombre ||\n    body.Nombre ||\n    'Paciente';\n\n  const servicio =\n    (parsed.servicio || '').trim() ||\n    body.servicio ||\n    body.Servicio ||\n    'Cita';\n\n  // Fecha/hora originales (texto natural)\n  const fechaOriginalTexto = parsed.fecha_original || body.fecha_original || '';\n  let   horaOriginalTexto  = parsed.hora_original  || body.hora_original  || '';\n\n  // Fecha/hora nuevas (texto natural)\n  const fechaNuevaTexto = parsed.fecha_nueva || body.fecha_nueva || '';\n  let   horaNuevaTexto  = parsed.hora_nueva  || body.hora_nueva  || '';\n\n  // Normalizamos servicio\n  const servicioLimpio = servicio\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .trim();\n\n  const colorId = mapaServicioColor[servicioLimpio] || '9';\n  const duracionMin = mapaDuracionServicioMin[servicioLimpio] || 60;\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FECHA/HORA ORIGINAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n  const fechaOriginalNormalizada = normalizarFechaFallback(fechaOriginalTexto);\n\n  // Hora original ‚Üí HH:MM\n  const partesHoraOrg = String(horaOriginalTexto || '').split(':');\n  let hOrg = (partesHoraOrg[0] || '').replace(/[^\\d]/g, '');\n  if (!hOrg) hOrg = '10';\n  hOrg = hOrg.padStart(2, '0');\n  const mOrg = (partesHoraOrg[1] || '00').replace(/[^\\d]/g, '').padStart(2, '0');\n  const horaOriginalNormalizada = `${hOrg}:${mOrg}`;\n\n  // start_original: para buscar el evento actual\n  const startOriginal = `${fechaOriginalNormalizada}T${horaOriginalNormalizada}:00`;\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FECHA/HORA NUEVA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n  const fechaNuevaNormalizada = normalizarFechaFallback(fechaNuevaTexto);\n\n  const partesHoraNueva = String(horaNuevaTexto || '').split(':');\n  let hNew = (partesHoraNueva[0] || '').replace(/[^\\d]/g, '');\n  if (!hNew) hNew = hOrg; // si no hay hora nueva, usamos la original\n  hNew = hNew.padStart(2, '0');\n  const mNew = (partesHoraNueva[1] || '00').replace(/[^\\d]/g, '').padStart(2, '0');\n  const horaNuevaNormalizada = `${hNew}:${mNew}`;\n\n  const startNuevo = `${fechaNuevaNormalizada}T${horaNuevaNormalizada}:00`;\n\n  // Calculamos end_nuevo sumando duraci√≥n\n  let hNewNum = parseInt(hNew, 10);\n  let mNewNum = parseInt(mNew, 10);\n\n  let totalMinNew = hNewNum * 60 + mNewNum + duracionMin;\n  let endHourNum = Math.floor(totalMinNew / 60);\n  let endMinNum = totalMinNew % 60;\n\n  if (endHourNum > 23) endHourNum = 23;\n\n  const endHoraStr = `${String(endHourNum).padStart(2, '0')}:${String(\n    endMinNum\n  ).padStart(2, '0')}:00`;\n  const endNuevo = `${fechaNuevaNormalizada}T${endHoraStr}`;\n\n  // Summary y descripci√≥n NUEVA (lo que quedar√° despu√©s de mover)\n  const summaryNuevo = `Cita para ${nombre} en ${servicio}`;\n\n  const descriptionLinesNuevo = [\n    `Servicio: ${servicio}`,\n    `Nombre: ${nombre}`,\n    `Duraci√≥n prevista: ${duracionMin} minutos`,\n    `Cita modificada desde: ${fechaOriginalTexto || fechaOriginalNormalizada} ${horaOriginalTexto || horaOriginalNormalizada}`,\n  ].filter(Boolean);\n\n  const descriptionNuevo = descriptionLinesNuevo.join('\\n');\n\n  return {\n    json: {\n      ...item.json,\n      tipo,\n      nombre,\n      servicio,\n      servicio_limpio: servicioLimpio,\n      colorId,\n      duracion_min: duracionMin,\n\n      // Datos originales\n      fecha_original_texto: fechaOriginalTexto,\n      hora_original_texto: horaOriginalTexto,\n      fecha_original_normalizada: fechaOriginalNormalizada,\n      hora_original_normalizada: horaOriginalNormalizada,\n      start_original: startOriginal,\n\n      // Datos nuevos\n      fecha_nueva_texto: fechaNuevaTexto,\n      hora_nueva_texto: horaNuevaTexto,\n      fecha_nueva_normalizada: fechaNuevaNormalizada,\n      hora_nueva_normalizada: horaNuevaNormalizada,\n      start_nuevo: startNuevo,\n      end_nuevo: endNuevo,\n\n      // Para el Update de Google Calendar\n      summary_nuevo: summaryNuevo,\n      description_nuevo: descriptionNuevo,\n    },\n  };\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1824,
        1360
      ],
      "id": "3c147f5b-8df9-48c4-9177-8c206e77e6c7",
      "name": "JS normalizar_modificar_citas"
    },
    {
      "parameters": {
        "jsCode": "// Modo: Run Once for All Items\nconst eventos = $input.all();\n\n// Recuperar datos base del nodo de normalizaci√≥n\nconst base = $items('JS Normalizar modificar_cita', 0, 0).json || {};\n\n// Nombre y servicio que queremos localizar\nconst nombreBaseRaw = base.nombre || '';\nconst servicioBaseRaw = base.servicio_limpio || base.servicio || '';\n\nconst startOriginalISO = base.start_original || null; // YYYY-MM-DDTHH:MM:SS\n\n// Helper para normalizar texto (min√∫sculas + sin tildes)\nfunction normalizarTexto(str) {\n  return (str || '')\n    .toString()\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // quitar tildes\n    .trim();\n}\n\nconst nombreBaseNorm = normalizarTexto(nombreBaseRaw);\nconst servicioBaseNorm = normalizarTexto(servicioBaseRaw);\n\n// Helper para diferencia en minutos entre dos fechas ISO\nfunction diffMinutos(iso1, iso2) {\n  if (!iso1 || !iso2) return null;\n  const d1 = new Date(iso1);\n  const d2 = new Date(iso2);\n  if (isNaN(d1.getTime()) || isNaN(d2.getTime())) return null;\n  return Math.abs(d1.getTime() - d2.getTime()) / 60000;\n}\n\nlet coincidencias = [];\n\n// Recorrer todos los eventos devueltos por Get Many\nfor (const item of eventos) {\n  const ev = item.json || {};\n\n  const summary = ev.summary || '';\n  const description = ev.description || '';\n\n  const textoNorm = normalizarTexto(summary + ' ' + description);\n\n  const matchNombre =\n    nombreBaseNorm && textoNorm.includes(nombreBaseNorm);\n  const matchServicio =\n    servicioBaseNorm && textoNorm.includes(servicioBaseNorm);\n\n  if (!matchNombre || !matchServicio) {\n    continue; // este evento no es candidato\n  }\n\n  // Obtener start del evento\n  const startEv =\n    ev.start?.dateTime ||\n    (ev.start?.date ? ev.start.date + 'T00:00:00' : null);\n\n  const diff = diffMinutos(startOriginalISO, startEv);\n\n  coincidencias.push({\n    ev,\n    diffMin: diff,\n  });\n}\n\nlet eventoElegido = null;\nlet motivoNoSeguro = null;\n\nif (coincidencias.length === 0) {\n  // Ninguna cita coincide con nombre + servicio\n  return [\n    {\n      json: {\n        ...base,\n        found: false,\n        necesita_aclaracion: true,\n        motivo: 'No se ha encontrado ninguna cita que coincida con ese nombre y servicio en esa fecha.',\n      },\n    },\n  ];\n}\n\nif (coincidencias.length === 1) {\n  // Una √∫nica coincidencia clara\n  eventoElegido = coincidencias[0].ev;\n} else {\n  // Varias coincidencias ‚Üí intentamos elegir por proximidad horaria\n  const conDiff = coincidencias.filter(c => c.diffMin !== null);\n\n  if (conDiff.length === 0) {\n    // No tenemos info horaria fiable para distinguir\n    motivoNoSeguro = 'Hay varias citas con ese nombre y servicio y no se puede distinguir por hora.';\n  } else {\n    // Buscar la de menor diferencia en minutos\n    let mejor = conDiff[0];\n    for (const c of conDiff.slice(1)) {\n      if (c.diffMin < mejor.diffMin) {\n        mejor = c;\n      }\n    }\n\n    // Si la diferencia es razonable (por ejemplo <= 45 min), la aceptamos\n    if (mejor.diffMin <= 45) {\n      eventoElegido = mejor.ev;\n    } else {\n      motivoNoSeguro = `Hay varias citas con ese nombre y servicio, y la diferencia horaria m√≠nima (${mejor.diffMin.toFixed(\n        1\n      )} min) es demasiado grande como para estar seguros.`;\n    }\n  }\n}\n\nif (!eventoElegido) {\n  // Varias coincidencias y no hemos podido elegir de forma segura\n  return [\n    {\n      json: {\n        ...base,\n        found: false,\n        necesita_aclaracion: true,\n        motivo:\n          motivoNoSeguro ||\n          'Hay varias citas que coinciden con ese nombre y servicio. No se puede modificar de forma segura sin m√°s datos.',\n      },\n    },\n  ];\n}\n\n// Si llegamos aqu√≠, TENEMOS un √∫nico evento elegido con seguridad\nconst startEvento =\n  eventoElegido.start?.dateTime ||\n  (eventoElegido.start?.date ? eventoElegido.start.date + 'T00:00:00' : null);\n\nconst fechaEvento =\n  eventoElegido.start?.date ||\n  (eventoElegido.start?.dateTime\n    ? eventoElegido.start.dateTime.slice(0, 10)\n    : null);\n\nconst horaEvento =\n  eventoElegido.start?.dateTime\n    ? eventoElegido.start.dateTime.slice(11, 16)\n    : null;\n\nreturn [\n  {\n    json: {\n      ...base,\n      found: true,\n      necesita_aclaracion: false,\n      eventId: eventoElegido.id,\n      resumen_original: eventoElegido.summary,\n      fecha_evento_original: fechaEvento,\n      hora_evento_original: horaEvento,\n      start_evento_original: startEvento,\n      // Lo que ya viene preparado desde JS Normalizar modificar_cita\n      start_nuevo: base.start_nuevo,\n      end_nuevo: base.end_nuevo,\n      summary_nuevo: base.summary_nuevo,\n      description_nuevo: base.description_nuevo,\n      colorId: base.colorId,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        1360
      ],
      "id": "fe5025f6-b8e4-45ec-8fb8-ef59bf0f72f2",
      "name": "JS Buscar_evento_modificar"
    }
  ],
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "timezone": "Europe/Madrid",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "shared": [
    {
      "updatedAt": "2025-11-24T01:36:27.812Z",
      "createdAt": "2025-11-24T01:36:27.812Z",
      "role": "workflow:owner",
      "workflowId": "3JFoRTuAWwR3OGO8",
      "projectId": "4uSls6g8LWC7Ie72"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 4,
  "updatedAt": "2025-11-28T05:14:04.000Z",
  "versionId": "efaf5fa3-b986-45ae-806d-bfaa4e686237"
}